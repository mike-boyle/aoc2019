// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_string = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function parseInstruction(str) {
  var match = Caml_string.get(str, 0);
  var match$1 = Caml_format.caml_int_of_string($$String.sub(str, 1, str.length - 1 | 0));
  switch (match) {
    case 68 :
        return /* Down */Block.__(3, [match$1]);
    case 76 :
        return /* Left */Block.__(1, [match$1]);
    case 82 :
        return /* Right */Block.__(0, [match$1]);
    case 69 :
    case 70 :
    case 71 :
    case 72 :
    case 73 :
    case 74 :
    case 75 :
    case 77 :
    case 78 :
    case 79 :
    case 80 :
    case 81 :
    case 83 :
    case 84 :
        return /* Up */Block.__(2, [0]);
    case 85 :
        return /* Up */Block.__(2, [match$1]);
    default:
      return /* Up */Block.__(2, [0]);
  }
}

function doTheThing(xOperation, yOperation) {
  var fn = function (param, n) {
    var point_x = Curry._1(xOperation, param.x);
    var point_y = Curry._1(yOperation, param.y);
    var point_stepCount = param.stepCount + 1 | 0;
    var point = {
      x: point_x,
      y: point_y,
      stepCount: point_stepCount
    };
    if (n <= 1) {
      return /* :: */[
              point,
              /* [] */0
            ];
    } else {
      return List.append(fn(point, n - 1 | 0), /* :: */[
                  point,
                  /* [] */0
                ]);
    }
  };
  return fn;
}

function identity(v) {
  return v;
}

function pointsFromInstruction(p, instr) {
  switch (instr.tag | 0) {
    case /* Right */0 :
        return doTheThing((function (prim) {
                        return prim + 1 | 0;
                      }), identity)(p, instr[0]);
    case /* Left */1 :
        return doTheThing((function (prim) {
                        return prim - 1 | 0;
                      }), identity)(p, instr[0]);
    case /* Up */2 :
        return doTheThing(identity, (function (prim) {
                        return prim + 1 | 0;
                      }))(p, instr[0]);
    case /* Down */3 :
        return doTheThing(identity, (function (prim) {
                        return prim - 1 | 0;
                      }))(p, instr[0]);
    
  }
}

function manhattanDistance(param) {
  return Pervasives.abs(param.x) + Pervasives.abs(param.y) | 0;
}

function equal(i, j) {
  if (i.x === j.x) {
    return i.y === j.y;
  } else {
    return false;
  }
}

function hash(i) {
  return Caml_int32.imul(i.x, 10000) + i.y | 0;
}

var PointHash = {
  equal: equal,
  hash: hash
};

var PointHashTable = Hashtbl.Make(PointHash);

function findDistance(l1, l2) {
  var origin = {
    x: 0,
    y: 0,
    stepCount: 0
  };
  var partial_arg = /* :: */[
    origin,
    /* [] */0
  ];
  var getAllPoints = function (param) {
    return List.fold_left((function (points, instruction) {
                  var newPoints = pointsFromInstruction(List.hd(points), instruction);
                  return List.append(newPoints, points);
                }), partial_arg, param);
  };
  var instructions1 = Curry._1(getAllPoints, List.map(parseInstruction, l1));
  var instructions2 = Curry._1(getAllPoints, List.map(parseInstruction, l2));
  var tbl = Curry._1(PointHashTable.create, List.length(instructions1));
  var addToTable = Curry._1(PointHashTable.add, tbl);
  List.iter((function (a) {
          return Curry._2(addToTable, a, a);
        }), instructions1);
  var intersectingPoints = List.filter((function (element) {
            if (Caml_obj.caml_notequal(element, origin)) {
              var v = element;
              return Curry._2(PointHashTable.find_opt, tbl, v) !== undefined;
            } else {
              return false;
            }
          }))(instructions2);
  var stepDistance = function (p) {
    return Curry._2(PointHashTable.find, tbl, p).stepCount + p.stepCount | 0;
  };
  var param = List.map(stepDistance, intersectingPoints);
  return List.fold_left((function (prim, prim$1) {
                if (prim < prim$1) {
                  return prim;
                } else {
                  return prim$1;
                }
              }), Pervasives.max_int, param);
}

var things = Fs.readFileSync("./src/stuff.txt", "ascii");

var garbage = things.split("\n");

var match = $$Array.map((function (param) {
        return param.split(",");
      }), garbage);

if (match.length !== 2) {
  throw [
        Caml_builtin_exceptions.match_failure,
        /* tuple */[
          "prob3.re",
          100,
          4
        ]
      ];
}

var stuff1 = match[0];

var stuff2 = match[1];

console.log(findDistance($$Array.to_list(stuff1), $$Array.to_list(stuff2)));

var ex1 = /* :: */[
  "R8",
  /* :: */[
    "U5",
    /* :: */[
      "L5",
      /* :: */[
        "D3",
        /* [] */0
      ]
    ]
  ]
];

var ex2 = /* :: */[
  "U7",
  /* :: */[
    "R6",
    /* :: */[
      "D4",
      /* :: */[
        "L4",
        /* [] */0
      ]
    ]
  ]
];

exports.ex1 = ex1;
exports.ex2 = ex2;
exports.parseInstruction = parseInstruction;
exports.doTheThing = doTheThing;
exports.identity = identity;
exports.pointsFromInstruction = pointsFromInstruction;
exports.manhattanDistance = manhattanDistance;
exports.PointHash = PointHash;
exports.PointHashTable = PointHashTable;
exports.findDistance = findDistance;
exports.things = things;
exports.garbage = garbage;
exports.stuff1 = stuff1;
exports.stuff2 = stuff2;
/* PointHashTable Not a pure module */
